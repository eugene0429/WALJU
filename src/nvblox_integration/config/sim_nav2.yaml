# =============================================================================
# Nav2 + NVBlox Integrated Navigation Parameters
# NvbloxCostmapLayer를 사용하여 combined_map_slice 토픽을 직접 costmap으로 변환
# =============================================================================

bt_navigator:
  ros__parameters:
    use_sim_time: True
    global_frame: map
    robot_base_frame: base_link
    odom_topic: /odom
    bt_loop_duration: 10
    default_server_timeout: 20
    wait_for_service_timeout: 1000
    action_server_result_timeout: 900.0
    navigators: ['navigate_to_pose', 'navigate_through_poses']
    navigate_to_pose:
      plugin: "nav2_bt_navigator::NavigateToPoseNavigator"
    navigate_through_poses:
      plugin: "nav2_bt_navigator::NavigateThroughPosesNavigator"
    # Nav2 Jazzy에서는 plugin_lib_names가 기본 로드되므로 명시하지 않음
    # 중복 등록 시 "ID already registered" 오류 발생
    
    # ★ 커스텀 Behavior Tree 사용 - 재계획 주기 제어 (0.2Hz = 5초)
    # NOTE: This path is dynamically overridden by run_pipeline.sh via generate_nav2_params.py
    # If running standalone, update to your actual install path
    default_nav_to_pose_bt_xml: ""
    
    # ★ 경로 재계획 제어 파라미터
    # 경로와 로봇 거리가 이 값 이상일 때만 재계획 (작은 경로 변화 무시)
    path_replanning_threshold: 1.0  # 1m 이상 벗어나야 재계획

controller_server:
  ros__parameters:
    use_sim_time: True
    # GPU 부하 고려하되 5Hz는 너무 낮아 collision detection 오탐 유발 → 10Hz로 상향
    controller_frequency: 10.0
    min_x_velocity_threshold: 0.001
    min_y_velocity_threshold: 0.5
    min_theta_velocity_threshold: 0.001
    # 실패 허용치 높임 - 일시적 장애물 통과 허용
    failure_tolerance: 1.0
    # controller patience 늘림 (기본 5초 -> 10초)
    controller_patience: 10.0
    progress_checker_plugins: ["progress_checker"]
    goal_checker_plugins: ["general_goal_checker"]
    controller_plugins: ["FollowPath"]
    odom_topic: /odom
    
    # ★ cmd_vel 토픽을 /nav2_cmd_vel로 변경
    #    initial_rotation_controller가 이를 구독하고 /cmd_vel로 패스스루
    #    회전 중에는 패스스루를 중지하고 직접 /cmd_vel에 회전 명령 발행
    cmd_vel_topic: /nav2_cmd_vel

    progress_checker:
      plugin: "nav2_controller::SimpleProgressChecker"
      required_movement_radius: 0.3
      movement_time_allowance: 15.0

    general_goal_checker:
      stateful: True
      plugin: "nav2_controller::StoppedGoalChecker"
      xy_goal_tolerance: 0.25
      yaw_goal_tolerance: 0.25
      # StoppedGoalChecker 추가 파라미터: 로봇이 멈춰야 goal 달성
      rot_stopped_velocity: 0.25  # rad/s 이하면 회전 정지로 판정
      trans_stopped_velocity: 0.25  # m/s 이하면 이동 정지로 판정

    # =========================================================================
    # Regulated Pure Pursuit Controller (RPP)
    # 
    # ★ 초기 방향 정렬은 별도의 initial_rotation_controller 노드가 담당
    #    - RotationShimController 대신 커스텀 노드 사용
    #    - Nav2 경로 추종 시작 전에 목표 방향으로 회전
    # =========================================================================
    FollowPath:
      plugin: "nav2_regulated_pure_pursuit_controller::RegulatedPurePursuitController"
      
      # === 기본 속도 제한 ===
      desired_linear_vel: 0.5           # 목표 선속도 (m/s)
      max_linear_accel: 2.0             # 최대 선가속도 (m/s²)
      max_linear_decel: 2.0             # 최대 선감속도 (m/s²)
      lookahead_dist: 2.0               # 기본 lookahead 거리 (m)
      min_lookahead_dist: 0.5           # 최소 lookahead 거리 (m)
      max_lookahead_dist: 2.5           # 최대 lookahead 거리 (m)
      lookahead_time: 1.0               # 속도 기반 lookahead 시간 (s)
      
      # === 회전 속도 제한 ===
      max_angular_vel: 1.0              # 최대 각속도 (rad/s)
      max_angular_accel: 1.6            # 최대 각가속도 (rad/s²)
      
      # ★ 초기 회전은 커스텀 노드가 처리하므로 비활성화
      use_rotate_to_heading: false
      allow_reversing: false
      
      # === 경로 추종 안정성 파라미터 ===
      transform_tolerance: 0.3          # TF 변환 허용 오차 (s)
      use_velocity_scaled_lookahead_dist: true  # 속도에 따른 lookahead 조절
      min_approach_linear_velocity: 0.1         # 목표 접근 시 최소 속도 (m/s)
      approach_velocity_scaling_dist: 1.5       # 감속 시작 거리 (m)
      max_robot_pose_search_dist: 10.0          # 경로에서 로봇 위치 검색 최대 거리
      
      # === 곡률 기반 속도 조절 (Curvature Regulation) ===
      use_regulated_linear_velocity_scaling: true   # 곡률 기반 감속 활성화
      regulated_linear_scaling_min_radius: 0.9      # 감속 시작 회전 반경 (m)
      regulated_linear_scaling_min_speed: 0.25      # 곡률 감속 시 최소 속도 (m/s)
      
      # === 장애물 기반 속도 조절 (Cost Regulation) ===
      use_cost_regulated_linear_velocity_scaling: true  # 장애물 비용 기반 감속 활성화
      cost_scaling_dist: 0.6                            # 장애물 감속 거리 (m)
      cost_scaling_gain: 1.0                            # 비용 감속 강도 (높을수록 민감)
      inflation_cost_scaling_factor: 3.0                # inflation 비용 스케일링
      
      # === 충돌 감지 ===
      use_collision_detection: true     # 충돌 감지 활성화
      max_allowed_time_to_collision_up_to_carrot: 1.0  # 충돌까지 허용 시간 (s)

# =============================================================================
# LOCAL COSTMAP - NvbloxCostmapLayer 사용
# odom 프레임 기준, rolling window
# =============================================================================
local_costmap:
  local_costmap:
    ros__parameters:
      # GPU 부하 시 낮은 주기로 업데이트
      update_frequency: 2.0
      publish_frequency: 2.0
      global_frame: odom
      robot_base_frame: base_link
      use_sim_time: True
      rolling_window: true
      width: 10
      height: 10
      resolution: 0.05
      # depth inference 지연 허용
      transform_tolerance: 1.0
      footprint: "[[0.5, 0.33], [0.5, -0.33], [-0.5, -0.33], [-0.5, 0.33]]"
      always_send_full_costmap: True
      
      # =====================================================================
      # NvbloxCostmapLayer를 primary로 사용
      # nvblox의 ESDF slice를 직접 costmap으로 변환
      # =====================================================================
      plugins: ["nvblox_layer", "inflation_layer"]
      
      nvblox_layer:
        plugin: "nvblox::nav2::NvbloxCostmapLayer"
        enabled: True
        # IMPORTANT: local_costmap의 global_frame과 일치해야 함
        nav2_costmap_global_frame: odom
        # static 또는 combined_map_slice 사용
        nvblox_map_slice_topic: "/nvblox_node/static_map_slice"
        # True: 이진 costmap (장애물/자유), False: 거리 기반 그라디언트
        convert_to_binary_costmap: False
        # 그라디언트 모드 파라미터
        # max_obstacle_distance: 이 거리까지 cost 그라디언트 적용
        max_obstacle_distance: 2.5
        # inflation_distance: 이 거리 이내는 INSCRIBED (로봇 대각선 반경 이상으로 설정)
        # 로버 footprint 대각선: sqrt(0.5^2 + 0.33^2) ≈ 0.6m, 여유 포함 0.8m
        inflation_distance: 0.8
        max_cost_value: 252
        
      inflation_layer:
        plugin: "nav2_costmap_2d::InflationLayer"
        enabled: True
        # cost_scaling_factor 낮을수록 장애물 비용이 더 넓게 퍼짐 (더 보수적)
        # 1.0 = 매우 보수적, 5.0 = 덜 보수적
        cost_scaling_factor: 1.0
        # inflation_radius: 로봇 대각선 반경(0.6m) + 충분한 여유(0.4m) = 1.0m
        inflation_radius: 1.0

# =============================================================================
# GLOBAL COSTMAP - NvbloxCostmapLayer 사용
# map 프레임 기준, rolling window (SLAM 없이 exploration용)
# =============================================================================
global_costmap:
  global_costmap:
    ros__parameters:
      # GPU 부하 시 낮은 주기로 업데이트
      update_frequency: 1.0
      publish_frequency: 1.0
      global_frame: map
      robot_base_frame: base_link
      use_sim_time: True
      # depth inference 지연 허용
      transform_tolerance: 1.0
      footprint: "[[0.5, 0.33], [0.5, -0.33], [-0.5, -0.33], [-0.5, 0.33]]"
      
      # Rolling window for mapless navigation
      rolling_window: true
      width: 50
      height: 50
      resolution: 0.05
      track_unknown_space: true
      always_send_full_costmap: True
      
      # =====================================================================
      # NvbloxCostmapLayer를 primary로 사용
      # combined_map_slice: static + dynamic 장애물 통합
      # =====================================================================
      plugins: ["nvblox_layer", "inflation_layer"]
      
      nvblox_layer:
        plugin: "nvblox::nav2::NvbloxCostmapLayer"
        enabled: True
        # IMPORTANT: global_costmap의 global_frame과 일치해야 함
        nav2_costmap_global_frame: map
        # combined_map_slice 사용 (static + dynamic)
        nvblox_map_slice_topic: "/nvblox_node/static_map_slice"
        # Binary 모드 비활성화: 거리 기반 그라디언트로 footprint 고려
        convert_to_binary_costmap: False
        # 그라디언트 모드 파라미터 (global에도 필요)
        max_obstacle_distance: 2.5
        # 로버 footprint 대각선 + 여유
        inflation_distance: 0.8
        max_cost_value: 252
        
      inflation_layer:
        plugin: "nav2_costmap_2d::InflationLayer"
        enabled: True
        # cost_scaling_factor 낮을수록 장애물 비용이 더 넓게 퍼짐 (0.5 = 매우 보수적)
        cost_scaling_factor: 0.5
        # Global planner: 로봇 대각선 반경 + 넉넉한 여유 (1.2m)
        inflation_radius: 1.2

planner_server:
  ros__parameters:
    use_sim_time: True
    # ★ 경로 재계획 주기 대폭 감소: 20Hz → 1Hz (1초에 1번)
    # 너무 자주 재계획하면 출발 시 방향이 계속 바뀌는 문제 발생
    expected_planner_frequency: 1.0
    planner_plugins: ["GridBased"]
    GridBased:
      # SmacPlanner2D: footprint 기반 collision checking 수행
      plugin: "nav2_smac_planner::SmacPlanner2D"
      tolerance: 0.5
      # 미탐색(unknown) 영역 통과 허용 - 탐색하면서 동적으로 경로 수정
      allow_unknown: true
      max_iterations: 1000000
      max_on_approach_iterations: 1000
      max_planning_time: 5.0
      # cost_travel_multiplier: 높을수록 높은 비용 영역 회피 (5.0 = 장애물 근처 강하게 회피)
      cost_travel_multiplier: 5.0
      # 장애물 비용 임계값 (이 값 이상이면 통과 불가)
      # INSCRIBED(252)도 회피하도록 lethal_cost를 252로 설정
      lethal_cost: 252
      # 높은 비용 영역도 회피 (inscribed footprint 고려)
      allow_reverse_expansion: false
      smooth_path: true

smoother_server:
  ros__parameters:
    use_sim_time: True
    smoother_plugins: ["simple_smoother"]
    simple_smoother:
      plugin: "nav2_smoother::SimpleSmoother"
      tolerance: 1.0e-10
      max_its: 1000
      do_refinement: True

behavior_server:
  ros__parameters:
    use_sim_time: True
    local_costmap_topic: local_costmap/costmap_raw
    global_costmap_topic: global_costmap/costmap_raw
    local_footprint_topic: local_costmap/published_footprint
    global_footprint_topic: global_costmap/published_footprint
    cycle_frequency: 10.0
    behavior_plugins: ["spin", "backup", "drive_on_heading", "assisted_teleop", "wait"]
    spin:
      plugin: "nav2_behaviors::Spin"
    backup:
      plugin: "nav2_behaviors::BackUp"
    drive_on_heading:
      plugin: "nav2_behaviors::DriveOnHeading"
    wait:
      plugin: "nav2_behaviors::Wait"
    assisted_teleop:
      plugin: "nav2_behaviors::AssistedTeleop"
    local_frame: odom
    global_frame: map
    robot_base_frame: base_link
    transform_tolerance: 0.3
    simulate_ahead_time: 2.0
    max_rotational_vel: 1.0
    min_rotational_vel: 0.4
    rotational_acc_lim: 3.2

waypoint_follower:
  ros__parameters:
    use_sim_time: True
    loop_rate: 20
    stop_on_failure: false
    action_server_result_timeout: 900.0
    waypoint_task_executor_plugin: "wait_at_waypoint"
    wait_at_waypoint:
      plugin: "nav2_waypoint_follower::WaitAtWaypoint"
      enabled: True
      waypoint_pause_duration: 200

velocity_smoother:
  ros__parameters:
    use_sim_time: True
    smoothing_frequency: 20.0
    scale_velocities: False
    feedback: "OPEN_LOOP"
    max_velocity: [0.5, 0.0, 1.5]
    min_velocity: [-0.5, 0.0, -1.5]
    max_accel: [2.5, 0.0, 3.2]
    max_decel: [-2.5, 0.0, -3.2]
    odom_topic: /odom
    odom_duration: 0.1
    deadband_velocity: [0.0, 0.0, 0.0]
    velocity_timeout: 1.0
    # NVBlox 전용 설정: collision_monitor 미사용으로 velocity_smoother가 직접 cmd_vel 출력
    # smoothed_cmd_vel을 cmd_vel로 직접 remap (collision_monitor bypass)
    closed_loop: False

# =============================================================================
# collision_monitor 비활성화 (NVBlox 전용 - LiDAR 없음)
# NVBlox costmap layer가 장애물 회피를 처리하므로 collision_monitor 불필요
# lifecycle_manager의 node_names에서도 제외됨
# =============================================================================
# collision_monitor:
#   ros__parameters:
#     use_sim_time: True
#     ...

route_server:
  ros__parameters:
    use_sim_time: True

opennav_docking:
  ros__parameters:
    use_sim_time: True
    controller_frequency: 50.0
    initial_perception_timeout: 5.0
    wait_charge_timeout: 5.0
    dock_approach_timeout: 30.0
    undock_linear_tolerance: 0.05
    undock_angular_tolerance: 0.1
    max_retries: 3
    base_frame: "base_link"
    fixed_frame: "odom"
    dock_backwards: false
    dock_prestaging_tolerance: 0.5

    # 도킹 플러그인 (필요시 활성화)
    dock_plugins: []
    docks: []

lifecycle_manager:
  ros__parameters:
    use_sim_time: True
    autostart: True
    # NVBlox 전용: collision_monitor 제외 (LiDAR 미사용)
    # velocity_smoother가 cmd_vel을 직접 출력
    node_names: ['controller_server', 'smoother_server', 'planner_server',
                 'behavior_server', 'bt_navigator', 'waypoint_follower',
                 'velocity_smoother']
    # GPU 부하로 인한 heartbeat 지연 허용 (depth inference ~0.55s)
    bond_timeout: 10.0
    attempt_respawn_reconnection: True
    bond_respawn_max_duration: 15.0
